# 配置格式对比说明

我为Level2配置生成了**4种格式**，每种都有不同的优劣势：

## 📊 格式对比表

| 特性 | JSON | JSON5 | YAML | TOML |
|------|------|-------|------|------|
| **可读性** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **支持注释** | ❌ | ✅ 行注释 | ✅ 行注释 | ✅ 行注释 |
| **AI可读写** | ✅ | ✅ | ✅ | ✅ |
| **Unity原生支持** | ✅ | ❌ 需插件 | ❌ 需插件 | ❌ 需插件 |
| **语法严格度** | 严格 | 宽松 | 宽松 | 中等 |
| **学习曲线** | 低 | 低 | 中 | 中 |
| **行业常用度** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Git友好度** | ✅ | ✅ | ✅ | ✅ |
| **尾随逗号** | ❌ | ✅ | N/A | N/A |

---

## 1️⃣ JSON（标准版）

### 示例
```json
{
  "loop_id": "Unit1_Loop1",
  "objectives": {
    "main_case": {
      "type": "MainCase",
      "text": "蓝月亮歌舞厅谋杀案"
    }
  }
}
```

### 优点
- ✅ **Unity原生支持**（JsonUtility直接读取）
- ✅ 行业标准，工具链完善
- ✅ 语法简单，不易出错

### 缺点
- ❌ **不支持注释**（除非用特殊字段如`_comment`）
- ❌ 不支持尾随逗号（容易格式错误）
- ❌ 可读性一般

### 适合场景
- 需要Unity原生支持
- 团队熟悉JSON
- 不需要在配置里写注释

---

## 2️⃣ JSON5（增强版）

### 示例
```json5
{
  loop_id: "Unit1_Loop1",  // 循环ID
  objectives: {
    // 主线案件 - 始终显示
    main_case: {
      type: "MainCase",
      text: "蓝月亮歌舞厅谋杀案",  // 尾随逗号OK
    },
  },
}
```

### 优点
- ✅ **支持注释**（`//` 和 `/* */`）
- ✅ 支持尾随逗号
- ✅ 键名可以不加引号
- ✅ 比JSON更易读

### 缺点
- ❌ **Unity需要第三方插件**（如JSON5.NET）
- ⚠️ 行业采用度较低

### 适合场景
- 想要JSON的结构 + 注释功能
- 愿意安装插件
- 团队熟悉JavaScript

### Unity集成
```csharp
// 需要安装 JSON5.NET
using JSON5;
string json5 = File.ReadAllText("config.json5");
var config = JSON5Parser.Parse(json5);
```

---

## 3️⃣ YAML（最易读）

### 示例
```yaml
loop_id: Unit1_Loop1
objectives:
  # 主线案件 - 始终显示
  main_case:
    type: MainCase
    text: 蓝月亮歌舞厅谋杀案

  # 循环目标 - 带进度条
  phase_goal:
    type: PhaseGoal
    text: 到底是谁把我迷晕了...
    total_required: 4  # 需要4个证据
```

### 优点
- ✅ **可读性最强**（缩进清晰，像自然语言）
- ✅ 支持注释
- ✅ 无冗余符号（无括号/逗号）
- ✅ 广泛用于配置文件（如Docker、Kubernetes）

### 缺点
- ❌ **Unity需要插件**（如YamlDotNet）
- ⚠️ 对缩进敏感（Tab/空格混用会报错）
- ⚠️ 语法相对复杂（锚点、引用等高级特性）

### 适合场景
- 策划主导，注重可读性
- 愿意学习YAML语法
- 配置文件较大，需要清晰结构

### Unity集成
```csharp
// 需要安装 YamlDotNet
using YamlDotNet.Serialization;
var deserializer = new DeserializerBuilder().Build();
var config = deserializer.Deserialize<LoopConfig>(yamlText);
```

---

## 4️⃣ TOML（最严格）

### 示例
```toml
loop_id = "Unit1_Loop1"

# 主线案件 - 始终显示
[objectives.main_case]
type = "MainCase"
text = "蓝月亮歌舞厅谋杀案"

# 循环目标 - 带进度条
[objectives.phase_goal]
type = "PhaseGoal"
total_required = 4  # 需要4个证据
```

### 优点
- ✅ **支持注释**
- ✅ 语义明确（用`[section]`划分区块）
- ✅ 类型安全（字符串必须加引号）
- ✅ 广泛用于配置（如Rust的Cargo.toml）

### 缺点
- ❌ **Unity需要插件**（如Tomlyn）
- ⚠️ 嵌套深的结构会很冗长
- ⚠️ 数组语法不如YAML/JSON5简洁

### 适合场景
- 配置结构扁平
- 需要严格类型检查
- 团队熟悉Rust/Python生态

### Unity集成
```csharp
// 需要安装 Tomlyn
using Tomlyn;
var config = Toml.ToModel<LoopConfig>(tomlText);
```

---

## 🎯 我的推荐

### 方案A：JSON + 内置注释字段（最兼容）

**适合您的情况**：
- ✅ Unity原生支持，无需插件
- ✅ AI完全支持读写
- ✅ 通过`_comment`字段实现注释效果
- ✅ 团队学习成本最低

**示例**：见 `Level2_Unit1_Loop1_Config_可读增强版.json`

---

### 方案B：YAML（最易读）

**如果您愿意装插件**：
- ✅ 可读性最强
- ✅ 策划编辑最舒服
- ✅ AI完全支持
- ⚠️ 需要YamlDotNet插件

**转换工作量**：5分钟装插件 + 10行代码

---

### 方案C：JSON5（折中方案）

**如果您想要注释但保持JSON结构**：
- ✅ 保持JSON的结构
- ✅ 支持真正的注释
- ⚠️ 需要JSON5插件

---

## 💡 实际工作流建议

### 推荐工作流：YAML策划版 + JSON程序版

```
1. 您用YAML编辑（可读性最强）
   ├─ 在VSCode/Obsidian里编辑
   └─ 发给我检查/修改

2. 我生成两个版本
   ├─ config.yaml（给您看的）
   └─ config.json（给Unity用的）

3. 修改时
   ├─ 您改YAML
   ├─ 我自动转成JSON
   └─ Unity加载JSON
```

**好处**：
- ✅ 您编辑时看的是最易读的YAML
- ✅ Unity用的是原生支持的JSON
- ✅ 两者同步，不会出错

---

## 🔄 格式转换

所有格式都可以互相转换：

```
YAML ←→ JSON ←→ JSON5 ←→ TOML
  ↓      ↓       ↓       ↓
 AI可以自动转换，无需手动
```

---

## ❓ 您的选择

请告诉我：

1. **您更喜欢哪种格式？**
   - JSON（兼容性最好）
   - JSON5（有注释的JSON）
   - YAML（最易读）
   - TOML（最严格）

2. **您愿意装Unity插件吗？**
   - 愿意 → 推荐YAML
   - 不愿意 → 推荐JSON+内置注释

3. **您想要什么工作流？**
   - 方案A：直接用JSON（我已经做了增强版）
   - 方案B：用YAML编辑，我转成JSON
   - 方案C：其他想法？

---

## 📁 已生成的文件

```
d:\NDC_project\AI生成\其他格式对比\
├── Level2_Loop1_YAML版本.yaml       ← 可读性最强
├── Level2_Loop1_TOML版本.toml       ← 最严格
├── Level2_Loop1_JSON5版本.json5     ← JSON+注释
└── 格式对比说明.md                   ← 本文档
```

您可以分别打开看看，选一个最喜欢的！
